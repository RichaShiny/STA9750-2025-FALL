---
title: "MINI-PROJECT #02 - Making Backyards Affordable for All"
format: html
theme: flatly
author: "Richa Shiny Tigiripally"
date: "2025-11-02"
--- 

![](images/FINAL-ALT-affordable-housing-cp-videoSixteenByNine3000-v2.jpg)

# EXECUTIVE SUMMARY

I took the national housing data, blended it with employment and income stats, and asked one bold question: Do cities that build more housing actually make rent suck less? Spoiler: yes.

By creating two indices: Rent Burden (how painful rent feels) and Housing Growth (how much a city is actually building), we discovered a simple truth:

Cities that build → rent goes down

Cities that don’t → rent goes up

I crowned one metro a YIMBY champion (building enough homes) and called out one NIMBY troublemaker (talking about growth but not actually permitting anything). Then we identified two occupations that benefit most from more housing, because teachers and nurses shouldn’t have to choose between paying rent and buying groceries.

In short: housing math is not mysterious. Build more. Panic less.

# DATA ACQUISITION

# TASK 1: DATA IMPORT

We’ll use the tidycensus package to pull ACS data, so instead of wrestling with raw Census files, R does the heavy lifting for us.

```{r}
#| code-fold: true
#| code-summary: "Show code:"

if(!dir.exists(file.path("data", "mp02"))){
    dir.create(file.path("data", "mp02"), showWarnings=FALSE, recursive=TRUE)
}

library <- function(pkg){
    ## Mask base::library() to automatically install packages if needed
    ## Masking is important here so downlit picks up packages and links
    ## to documentation
    pkg <- as.character(substitute(pkg))
    options(repos = c(CRAN = "https://cloud.r-project.org"))
    if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)
    stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))
}

library(tidyverse)
library(glue)
library(readxl)
library(tidycensus)

get_acs_all_years <- function(variable, geography="cbsa",
                              start_year=2009, end_year=2023){
    fname <- glue("{variable}_{geography}_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        YEARS <- seq(start_year, end_year)
        YEARS <- YEARS[YEARS != 2020] # Drop 2020 - No survey (covid)
        
        ALL_DATA <- map(YEARS, function(yy){
            tidycensus::get_acs(geography, variable, year=yy, survey="acs1") |>
                mutate(year=yy) |>
                select(-moe, -variable) |>
                rename(!!variable := estimate)
        }) |> bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
}

# Household income (12 month)
INCOME <- get_acs_all_years("B19013_001") |>
    rename(household_income = B19013_001)

# Monthly rent
RENT <- get_acs_all_years("B25064_001") |>
    rename(monthly_rent = B25064_001)

# Total population
POPULATION <- get_acs_all_years("B01003_001") |>
    rename(population = B01003_001)

# Total number of households
HOUSEHOLDS <- get_acs_all_years("B11001_001") |>
    rename(households = B11001_001)

```

Housing permits aren’t available in tidycensus, so we’ll download and prep that dataset manually.

```{r}
#| code-fold: true
#| code-summary: "Show code:"

get_building_permits <- function(start_year = 2009, end_year = 2023){
    fname <- glue("housing_units_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        HISTORICAL_YEARS <- seq(start_year, 2018)
        
        HISTORICAL_DATA <- map(HISTORICAL_YEARS, function(yy){
            historical_url <- glue("https://www.census.gov/construction/bps/txt/tb3u{yy}.txt")
                
            LINES <- readLines(historical_url)[-c(1:11)]

            CBSA_LINES <- str_detect(LINES, "^[[:digit:]]")
            CBSA <- as.integer(str_sub(LINES[CBSA_LINES], 5, 10))

            PERMIT_LINES <- str_detect(str_sub(LINES, 48, 53), "[[:digit:]]")
            PERMITS <- as.integer(str_sub(LINES[PERMIT_LINES], 48, 53))
            
            data_frame(CBSA = CBSA,
                       new_housing_units_permitted = PERMITS, 
                       year = yy)
        }) |> bind_rows()
        
        CURRENT_YEARS <- seq(2019, end_year)
        
        CURRENT_DATA <- map(CURRENT_YEARS, function(yy){
            current_url <- glue("https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls")
            
            temp <- tempfile()
            
            download.file(current_url, destfile = temp, mode="wb")
            
            fallback <- function(.f1, .f2){
                function(...){
                    tryCatch(.f1(...), 
                             error=function(e) .f2(...))
                }
            }
            
            reader <- fallback(read_xlsx, read_xls)
            
            reader(temp, skip=5) |>
                na.omit() |>
                select(CBSA, Total) |>
                mutate(year = yy) |>
                rename(new_housing_units_permitted = Total)
        }) |> bind_rows()
        
        ALL_DATA <- rbind(HISTORICAL_DATA, CURRENT_DATA)
        
        write_csv(ALL_DATA, fname)
        
    }
    
    read_csv(fname, show_col_types=FALSE)
}

PERMITS <- get_building_permits()
```

We’ll analyze data at the CBSA (metro area) level and use BLS NAICS codes to match housing trends with local industries and incomes.

```{r}
#| code-fold: true
#| code-summary: "Show code:"
library(httr2)
library(rvest)
get_bls_industry_codes <- function(){
    fname <- file.path("data", "mp02", "bls_industry_codes.csv")
    library(dplyr)
    library(tidyr)
    library(readr)
    
    if(!file.exists(fname)){
        
        resp <- request("https://www.bls.gov") |> 
            req_url_path("cew", "classifications", "industry", "industry-titles.htm") |>
            req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
            req_error(is_error = \(resp) FALSE) |>
            req_perform()
        
        resp_check_status(resp)
        
        naics_table <- resp_body_html(resp) |>
            html_element("#naics_titles") |> 
            html_table() |>
            mutate(title = str_trim(str_remove(str_remove(`Industry Title`, Code), "NAICS"))) |>
            select(-`Industry Title`) |>
            mutate(depth = if_else(nchar(Code) <= 5, nchar(Code) - 1, NA)) |>
            filter(!is.na(depth))
        
        # These were looked up manually on bls.gov after finding 
        # they were presented as ranges. Since there are only three
        # it was easier to manually handle than to special-case everything else
        naics_missing <- tibble::tribble(
            ~Code, ~title, ~depth, 
            "31", "Manufacturing", 1,
            "32", "Manufacturing", 1,
            "33", "Manufacturing", 1,
            "44", "Retail", 1, 
            "45", "Retail", 1,
            "48", "Transportation and Warehousing", 1, 
            "49", "Transportation and Warehousing", 1
        )
        
        naics_table <- bind_rows(naics_table, naics_missing)
        
        naics_table <- naics_table |> 
            filter(depth == 4) |> 
            rename(level4_title=title) |> 
            mutate(level1_code = str_sub(Code, end=2), 
                   level2_code = str_sub(Code, end=3), 
                   level3_code = str_sub(Code, end=4)) |>
            left_join(naics_table, join_by(level1_code == Code)) |>
            rename(level1_title=title) |>
            left_join(naics_table, join_by(level2_code == Code)) |>
            rename(level2_title=title) |>
            left_join(naics_table, join_by(level3_code == Code)) |>
            rename(level3_title=title) |>
            select(-starts_with("depth")) |>
            rename(level4_code = Code) |>
            select(level1_title, level2_title, level3_title, level4_title, 
                   level1_code,  level2_code,  level3_code,  level4_code) |>
            drop_na() |>
            mutate(across(contains("code"), as.integer))
        
        write_csv(naics_table, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
}

INDUSTRY_CODES <- get_bls_industry_codes()
```

The BLS Quarterly Census of Employment and Wages

```{r}
#| code-fold: true
#| code-summary: "Show code:"

library(httr2)
library(rvest)
get_bls_qcew_annual_averages <- function(start_year=2009, end_year=2023){
    fname <- glue("bls_qcew_{start_year}_{end_year}.csv.gz")
    fname <- file.path("data", "mp02", fname)
    
    YEARS <- seq(start_year, end_year)
    YEARS <- YEARS[YEARS != 2020] # Drop Covid year to match ACS
    
    if(!file.exists(fname)){
        ALL_DATA <- map(YEARS, .progress=TRUE, possibly(function(yy){
            fname_inner <- file.path("data", "mp02", glue("{yy}_qcew_annual_singlefile.zip"))
            
            if(!file.exists(fname_inner)){
                request("https://www.bls.gov") |> 
                    req_url_path("cew", "data", "files", yy, "csv",
                                 glue("{yy}_annual_singlefile.zip")) |>
                    req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
                    req_retry(max_tries=5) |>
                    req_perform(fname_inner)
            }
            
            if(file.info(fname_inner)$size < 755e5){
                warning(sQuote(fname_inner), "appears corrupted. Please delete and retry this step.")
            }
            
            read_csv(fname_inner, 
                     show_col_types=FALSE) |> 
                mutate(YEAR = yy) |>
                select(area_fips, 
                       industry_code, 
                       annual_avg_emplvl, 
                       total_annual_wages, 
                       YEAR) |>
                filter(nchar(industry_code) <= 5, 
                       str_starts(area_fips, "C")) |>
                filter(str_detect(industry_code, "-", negate=TRUE)) |>
                mutate(FIPS = area_fips, 
                       INDUSTRY = as.integer(industry_code), 
                       EMPLOYMENT = as.integer(annual_avg_emplvl), 
                       TOTAL_WAGES = total_annual_wages) |>
                select(-area_fips, 
                       -industry_code, 
                       -annual_avg_emplvl, 
                       -total_annual_wages) |>
                # 10 is a special value: "all industries" , so omit
                filter(INDUSTRY != 10) |> 
                mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)
        })) |> bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    ALL_DATA <- read_csv(fname, show_col_types=FALSE)
    
    ALL_DATA_YEARS <- unique(ALL_DATA$YEAR)
    
    YEARS_DIFF <- setdiff(YEARS, ALL_DATA_YEARS)
    
    if(length(YEARS_DIFF) > 0){
        stop("Download failed for the following years: ", YEARS_DIFF, 
             ". Please delete intermediate files and try again.")
    }
    
    ALL_DATA
}

WAGES <- get_bls_qcew_annual_averages()
```

# DATA INTEGRATION AND INITIAL EXPLORATION

# Task 2: Multi-Table Questions

### Q1. Which CBSA (by name) permitted the largest number of new housing units in the decade from 2010 to 2019 (inclusive)?

```{r}
#| code-fold: true
#| code-summary: "Show code:"

library(dplyr)
library(scales)

TopPermits <- PERMITS %>%
  filter(year >= 2010, year <= 2019) %>%
  group_by(CBSA) %>%
  summarise(total_permits = sum(new_housing_units_permitted, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(total_permits)) %>%
  slice(1) %>%
  left_join(INCOME %>% distinct(GEOID, NAME), by = c("CBSA" = "GEOID"))

# Show the exact number (no scaling) nicely formatted
TopPermits %>%
  mutate(total_permits_fmt = comma(total_permits))

```

### Conclusion:

The output identifies the CBSA that issued the highest total number of new housing permits across the full decade. By aggregating permits year-by-year and ranking metros from highest to lowest, this reveals the metro area that experienced the most sustained level of residential construction activity over the 10-year period rather than a one-year spike.

### Q2: In what year did Albuquerque, NM (CBSA Number 10740) permit the most new housing units?

```{r}
#| code-fold: true
#| code-summary: "Show code:"

albuquerque_peak_year <- PERMITS |>
filter(CBSA == 10740) |>
arrange(desc(new_housing_units_permitted)) |>
slice_max(new_housing_units_permitted, n = 1, with_ties = FALSE) |>
select(year, new_housing_units_permitted)
albuquerque_peak_year

```

### Conclusion:

Albuquerque’s permitting activity fluctuates significantly from year to year. The output highlights the single year, 2021 with the highest number of new housing permits: 4021, capturing the true peak of construction activity in the dataset.

### Q3: Which state (not CBSA) had the highest average individual income in 2015? To answer this question, you will need to first compute the total income per CBSA by multiplying the average household income by the number of households, and then sum total income and total population across all CBSAs in a state. With these numbers, you can answer this question.

```{r}
#| code-fold: true
#| code-summary: "Show code:"

income_state <- INCOME |>
filter(year == 2015) |>
left_join(HOUSEHOLDS |> filter(year == 2015), by = c("GEOID", "NAME")) |>
left_join(POPULATION |> filter(year == 2015), by = c("GEOID", "NAME")) |>
mutate(total_income = household_income * households,
state = str_extract(NAME, ", (.{2})", group = 1)) |>
group_by(state) |>
summarize(state_income = sum(total_income, na.rm = TRUE),
state_pop = sum(population, na.rm = TRUE),
avg_individual_income = state_income / state_pop,
.groups = "drop") |>
slice_max(avg_individual_income, n = 1)

income_state

```

### Conclusion:

In 2015, the state with the highest average individual income was the District of Columbia. After aggregating all CBSAs within each state and computing total income (average household income × number of households) and total population, DC had approximately \$202.7 billion in total income across 6,098,283 residents, resulting in an average individual income of about \$33,233 per person. Although DC is not a state, the U.S. Census Bureau treats it as a state-equivalent for statistical reporting, and it ranks #1 nationally under that classification.

### Q4: Data scientists and business analysts are recorded under NAICS code 5182. What is the last year in which the NYC CBSA had the most data scientists in the country? In recent, the San Francisco CBSA has had the most data scientists.

### For this question, you may simply create a table of which CBSA had the most data scientists each year and then answer the question in the following text.

### Note that the Census Bureau and the BLS use different conventions when recording CBSA identification numbers. To join these tables together, you will need to create a new column to join on. In particular, the BLS will record a code a “C1234” corresponding to a Census identifier of “12340” for the same region. To match these up, it is easiest to create a new column in the BLS tables which transforms values like “C1234” into “12340”-formatted values.

```{r}
#| code-fold: true
#| code-summary: "Show code:"

library(dplyr)
library(stringr)
library(tibble)

# 1) Helper to convert BLS FIPS (e.g., "C1234") -> Census CBSA numeric (e.g., 12340)
bls_to_cbsa <- function(fips_chr) {
  fips_chr %>%
    str_remove("^C") %>%     # drop leading "C"
    as.double() %>%          # make numeric
    (`*`)(10)                # append trailing 0
}

# (Optional) show the transformation works, as a tibble:
example_transform <- tibble(
  input  = c("C1234", "C3562", "C4186"),
  output = bls_to_cbsa(input)
)
example_transform
#   input  output
# 1 C1234   12340
# 2 C3562   35620
# 3 C4186   41860

# 2) Get a CBSA -> NAME lookup from your ACS tables
cbsa_names <- INCOME %>%
  distinct(GEOID, NAME) %>%
  rename(CBSA = GEOID)

# 3) Top CBSA per year for NAICS 5182 (data processing/hosting)
top_by_year_5182 <- WAGES %>%
  filter(INDUSTRY == 5182) %>%
  mutate(CBSA = bls_to_cbsa(FIPS)) %>%
  group_by(YEAR, CBSA) %>%
  summarise(EMPLOYMENT = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop") %>%
  group_by(YEAR) %>%
  slice_max(EMPLOYMENT, n = 1, with_ties = FALSE) %>%  # the #1 CBSA for that year
  ungroup() %>%
  left_join(cbsa_names, by = "CBSA") %>%
  arrange(desc(YEAR))

top_by_year_5182
# A tibble with columns: YEAR, CBSA, EMPLOYMENT, NAME (top metro per year)

# 4) The most recent year NYC (CBSA 35620) was #1
nyc_last_top_5182 <- top_by_year_5182 %>%
  filter(CBSA == 35620) %>%
  slice_max(YEAR, n = 1)

nyc_last_top_5182
# A one-row tibble showing the last YEAR NYC led NAICS 5182 (with EMPLOYMENT and NAME)

```

### Conclusion:

By converting the BLS CBSA codes (e.g., "C3562") into Census-formatted CBSA identifiers (35620) and aggregating employment under NAICS 5182, we identified which metro area had the highest number of data-science-related jobs each year. After ranking metros annually, we extracted the most recent year in which the New York–Newark–Jersey City CBSA held the #1 position. The tibble output confirms that New York was the top metro for NAICS 5182 in that specific year, but in subsequent years, another metro surpassed it. This provides clear evidence of a shift in data-science employment concentration over time.

In short, NYC once led the country in data-science employment, but more recent years show another metro overtaking it, signaling a shift in where data-driven industries are clustering.

### Q5:What fraction of total wages in the NYC CBSA was earned by people employed in the finance and insurance industries (NAICS code 52)? In what year did this fraction peak?

```{r}
#| code-fold: true
#| code-summary: "Show code:"

library(dplyr)
library(stringr)
library(tibble)

# Helper used before: convert BLS FIPS like "C3562" -> Census CBSA 35620
bls_to_cbsa <- function(fips_chr) {
  fips_chr %>%
    str_remove("^C") %>%
    as.double() %>%
    (`*`)(10)
}

nyc_cbsa <- 35620  # NYC CBSA

# 1) Compute NYC finance share of total wages, by year
nyc_finance_share <- WAGES %>%
  mutate(CBSA = bls_to_cbsa(FIPS)) %>%
  filter(CBSA == nyc_cbsa) %>%
  group_by(YEAR) %>%
  summarise(
    total_wages_all = sum(TOTAL_WAGES, na.rm = TRUE),
    total_wages_fin = sum(TOTAL_WAGES[INDUSTRY == 52], na.rm = TRUE),
    frac_fin        = total_wages_fin / total_wages_all,
    .groups = "drop"
  ) %>%
  arrange(YEAR)

nyc_finance_share
# A tibble with YEAR, total_wages_all, total_wages_fin, frac_fin

# 2) Peak year for finance wage share
nyc_finance_peak <- nyc_finance_share %>%
  slice_max(frac_fin, n = 1, with_ties = FALSE)

nyc_finance_peak
```

### Conclusion:

In 2014, workers employed in the finance and insurance sector (NAICS 52) earned \$119,105,615,711 out of a total \$2,587,096,519,796 in wages in the NYC CBSA. This means that approximately 4.6% of all wages earned in the New York metropolitan area that year came from finance and insurance jobs. While NYC has a reputation for being heavily finance-driven, this result shows that finance represents a significant but not majority share of total wage activity, indicating a more diversified wage base than commonly assumed.

In short, NYC’s wage base is dominated by finance, in its peak year(2014), over one-quarter of all income earned in the metro area came from financial and insurance jobs alone.

# TASK 3: INITIAL VISUALIZATIONS

### Q1: The relationship between monthly rent and average household income per CBSA in 2009.

```{r}
#| code-fold: true
#| code-summary: "Show code:"

library(dplyr)
library(ggplot2)
library(scales)
library(stringr)

# helper: standardize id column to CBSA if it's named GEOID
std_cbsa <- function(df) {
  if ("GEOID" %in% names(df)) df <- dplyr::rename(df, CBSA = GEOID)
  df
}

# 1) Prep: join 2009 ACS rent & income at CBSA level (handle GEOID/CBSA names)
rent_2009 <- RENT  |> std_cbsa() |> filter(year == 2009) |> select(CBSA, NAME, year, monthly_rent)
inc_2009  <- INCOME |> std_cbsa() |> filter(year == 2009) |> select(CBSA, NAME, year, household_income)

rent_income_2009 <- inner_join(rent_2009, inc_2009, by = c("CBSA","NAME","year")) |>
  filter(!is.na(monthly_rent), !is.na(household_income))

# 2) Correlation for caption
r_val   <- cor(rent_income_2009$household_income, rent_income_2009$monthly_rent, use = "complete.obs")
ann_txt <- paste0("Pearson r = ", number(r_val, accuracy = 0.01))

# 3) Plot: density background + points + OLS fit + clean dollars
ggplot(rent_income_2009, aes(x = household_income, y = monthly_rent)) +
  geom_density_2d_filled(contour_var = "ndensity", alpha = 0.6) +
  geom_point(alpha = 0.55, size = 1.7) +
  geom_smooth(method = "lm", se = TRUE, linewidth = 0.9) +
  scale_x_continuous(labels = dollar_format(accuracy = 1), expand = expansion(mult = c(0.02, 0.05))) +
  scale_y_continuous(labels = dollar_format(accuracy = 1), expand = expansion(mult = c(0.02, 0.08))) +
  labs(
    title = "Monthly Rent vs Household Income per CBSA (2009)",
    subtitle = "Higher-income metros tend to have higher median rents",
    x = "Median Household Income (ACS 1-year, USD)",
    y = "Median Gross Rent (ACS 1-year, USD)",
    caption = ann_txt
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold"),
    legend.position = "none",
    panel.grid.minor = element_blank()
  )
```

### Q2: The relationship between total employment and total employment in the health care and social services sector (NAICS 62) across different CBSAs. Design your visualization so that it is possible to see the evolution of this relationship over time.

```{r}
#| label: emp-vs-hc-over-time-pretty
#| fig-width: 10
#| fig-height: 7
#| fig-align: "center"
#| code-fold: true
#| #| code-summary: "Employment vs Health Care (evolution over time, with year legend & safe cor)"

library(dplyr)
library(stringr)
library(ggplot2)
library(scales)

# Helper: BLS "C3562" -> Census 35620
bls_to_cbsa <- function(fips_chr) {
  fips_chr |>
    str_remove("^C") |>
    as.double() |>
    (`*`)(10)
}

# CBSA name lookup (no curly RHS in pipes)
cbsa_names <- INCOME
if ("GEOID" %in% names(cbsa_names)) {
  cbsa_names <- dplyr::rename(cbsa_names, CBSA = GEOID)
}
cbsa_names <- cbsa_names %>%
  mutate(CBSA = as.double(CBSA)) %>%
  distinct(CBSA, NAME)

# Build tidy data: totals & NAICS 62 by CBSA-year
emp_hc <- WAGES %>%
  mutate(CBSA = bls_to_cbsa(FIPS)) %>%
  group_by(CBSA, YEAR) %>%
  summarise(
    emp_total = sum(EMPLOYMENT, na.rm = TRUE),
    emp_hc    = sum(EMPLOYMENT[INDUSTRY == 62], na.rm = TRUE),
    .groups = "drop"
  ) %>%
  left_join(cbsa_names, by = "CBSA") %>%
  filter(!is.na(emp_total), !is.na(emp_hc)) %>%
  mutate(
    YEAR   = as.integer(YEAR),      # numeric for math
    year_f = factor(YEAR)           # factor for legend colors
  )

# Safe latest-year correlation (guard against all-NA or <2 rows)
latest_year <- max(emp_hc$YEAR, na.rm = TRUE)
latest_df <- emp_hc %>%
  filter(YEAR == latest_year) %>%
  filter(!is.na(emp_total), !is.na(emp_hc))

r_latest <- if (nrow(latest_df) >= 2) {
  cor(latest_df$emp_total, latest_df$emp_hc, use = "complete.obs")
} else {
  NA_real_
}

cap_text <- if (is.na(r_latest)) {
  paste0("Latest year = ", latest_year, "; Pearson r not available (insufficient complete pairs)")
} else {
  paste0("Latest year = ", latest_year, "; Pearson r ≈ ", number(r_latest, accuracy = 0.01))
}

# Styled plot: paths show evolution; points colored by year; smoother in constant blue
col_blue <- "#4C78A8"

ggplot(emp_hc, aes(x = emp_total, y = emp_hc, group = CBSA)) +
  geom_path(color = col_blue, alpha = 0.35, linewidth = 0.8) +
  geom_point(aes(color = year_f), size = 2.3, alpha = 0.9) +
  geom_smooth(aes(group = 1), method = "lm", se = TRUE, linewidth = 1, color = col_blue) +
  scale_x_continuous(labels = comma, expand = expansion(mult = c(0.02, 0.05))) +
  scale_y_continuous(labels = comma, expand = expansion(mult = c(0.02, 0.08))) +
  scale_color_viridis_d(option = "D", direction = -1, name = "Year") +
  labs(
    title    = "Total Employment vs Health Care & Social Assistance (NAICS 62)",
    subtitle = "Each path traces a CBSA across years; point colors indicate the year",
    x = "Total Employment (QCEW)",
    y = "Health Care & Social Assistance Employment (QCEW, NAICS 62)",
    caption = cap_text
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    legend.position = "right"
  )

```

### Q3: The evolution of average household size over time. Use different lines to represent different CBSAs.

# EXTRA CREDIT #02: 1 point
# Household size over time — IQR band + NYC/LA
```{r}
#| label: hhsize-extra-credit
#| fig-width: 20
#| fig-height: 15
#| fig-align: "center"
#| code-fold: true


library(dplyr)
library(ggplot2)
library(scales)

# Computing household size by CBSA-year 
# Normalizing IDs to CBSA
POP <- POPULATION
HHS <- HOUSEHOLDS
if ("GEOID" %in% names(POP)) POP <- dplyr::rename(POP, CBSA = GEOID)
if ("GEOID" %in% names(HHS)) HHS <- dplyr::rename(HHS, CBSA = GEOID)

# Keeping needed columns 
POP <- POP %>% select(CBSA, NAME, year, population)
HHS <- HHS %>% select(CBSA, NAME, year, households)

# Household size time series (dropping obvious outliers)
hhsize_ts <- POP %>%
  inner_join(HHS, by = c("CBSA","NAME","year")) %>%
  mutate(
    YEAR = as.integer(year),
    household_size = population / households
  ) %>%
  filter(!is.na(household_size), household_size > 1, household_size < 6) %>%
  arrange(CBSA, YEAR)

# National context: median & IQR per year 
yr_summ <- hhsize_ts %>%
  group_by(YEAR) %>%
  summarise(
    q25 = quantile(household_size, 0.25, na.rm = TRUE),
    med = median(household_size, na.rm = TRUE),
    q75 = quantile(household_size, 0.75, na.rm = TRUE),
    .groups = "drop"
  )

#  Highlighting NYC & LA + end labels 
highlight_ids <- c(35620, 31180)  # NYC, Los Angeles
col_base <- "#4C78A8"; col_nyc <- "#4C78A8"; col_la <- "#F58518"

# % change from first to latest year (for highlighted CBSAs)
chg_df <- hhsize_ts %>%
  filter(CBSA %in% highlight_ids) %>%
  group_by(CBSA, NAME) %>%
  summarise(
    start_year = min(YEAR, na.rm = TRUE),
    end_year   = max(YEAR, na.rm = TRUE),
    start_val  = household_size[YEAR == start_year][1],
    end_val    = household_size[YEAR == end_year][1],
    pct_change = (end_val - start_val) / start_val,
    .groups = "drop"
  )

latest_year <- max(hhsize_ts$YEAR, na.rm = TRUE)

# End-of-series points for labels (latest year), using separate column name to avoid collisions
end_pts <- hhsize_ts %>%
  filter(CBSA %in% highlight_ids, YEAR == latest_year) %>%
  distinct(CBSA, NAME, YEAR, .keep_all = TRUE) %>%
  transmute(CBSA, NAME, YEAR, end_val_plot = household_size) %>%
  left_join(chg_df, by = c("CBSA","NAME")) %>%
  mutate(
    label = paste0(
      NAME, "\n",
      scales::number(end_val, accuracy = 0.01), " (",
      scales::percent(pct_change, accuracy = 0.1), " since ", start_year, ")"
    ),
    line_col = ifelse(grepl("^New York", NAME), col_nyc, col_la)
  )

#  Plot: spaghetti + IQR ribbon + median + arrows 
p <- ggplot() +
  # IQR band and median line (national context)
  geom_ribbon(data = yr_summ, aes(x = YEAR, ymin = q25, ymax = q75),
              fill = "#BDC6D1", alpha = 0.35) +
  geom_line(data = yr_summ, aes(YEAR, med), color = "#5A6B7A", linewidth = 1) +

  # Background spaghetti (all CBSAs)
  geom_line(data = hhsize_ts, aes(YEAR, household_size, group = CBSA),
            color = col_base, alpha = 0.18, linewidth = 0.6) +

# Highlighting NYC (blue) & LA (orange) as thicker lines
  geom_line(
    data = subset(hhsize_ts, CBSA %in% highlight_ids & grepl("^New York", NAME)),
    aes(YEAR, household_size),
    color = col_nyc, linewidth = 1.3
  ) +
  geom_line(
    data = subset(hhsize_ts, CBSA %in% highlight_ids & grepl("^Los Angeles", NAME)),
    aes(YEAR, household_size),
    color = col_la, linewidth = 1.3
  ) +

# Arrows pointing from end points to labels placed outside plot
  geom_curve(
    data = end_pts,
    aes(x = YEAR, y = end_val_plot, xend = YEAR + 0.25, yend = end_val_plot),
    curvature = -0.1, linewidth = 0.5,
    arrow = arrow(length = unit(0.15, "cm")),
    color = "gray30"
  ) +
  geom_point(
    data = end_pts,
    aes(x = YEAR, y = end_val_plot),
    color = end_pts$line_col, size = 2
  ) +
  geom_text(
    data = end_pts,
    aes(x = YEAR + 0.3, y = end_val_plot, label = label, color = line_col),
    hjust = 0, vjust = 0.5, size = 3.6, show.legend = FALSE
  ) +
  scale_color_identity() +  # use the colors we set in data
  scale_x_continuous(breaks = pretty(hhsize_ts$YEAR)) +
  scale_y_continuous(labels = number_format(accuracy = 0.1)) +
  labs(
    title = "Average Household Size Over Time",
    subtitle = "National IQR band & median; NYC and Los Angeles highlighted with end values and % change",
    x = "Year",
    y = "Average Household Size (persons)"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", margin = margin(b = 8)),
    plot.subtitle = element_text(margin = margin(b = 8)),
    panel.grid.minor = element_blank(),
    legend.position = "none",
    # extra right margin so labels have room
    plot.margin = margin(10, 90, 10, 10)
  ) +
# allow labels to render outside the panel (prevents clipping)
  coord_cartesian(clip = "off")

p
```

# Building Indices of Housing Affordability and Housing Stock Growth

# Task 4: RENT BURDEN
# Creating the Rent Burden Metric (Join INCOME + RENT + POPULATION)

Here, we combine data from the INCOME, RENT, and POPULATION Census tables.
We calculate a rent-to-income ratio, which represents how much of the typical household’s income goes toward rent.
Because raw ratios are difficult to interpret (e.g., 0.32 vs 0.28), we standardize this into a Rent Burden Index (RBI):

RBI = 100 : rent burden equal to the long-run national average
RBI > 100 : rent is less affordable than average
RBI < 100 : rent is more affordable than average

This makes comparisons across metros easier and lets us identify where people are most financially stretched by rent.

```{r}
#| label: rent-burden-index
#| code-fold: true
#| code-summary: "Show code: Construct Rent Burden Index"

library(dplyr)
library(scales)

# Rename GEOID if necessary
INC <- INCOME; REN <- RENT; POP <- POPULATION
if ("GEOID" %in% names(INC)) INC <- rename(INC, CBSA = GEOID)
if ("GEOID" %in% names(REN)) REN <- rename(REN, CBSA = GEOID)
if ("GEOID" %in% names(POP)) POP <- rename(POP, CBSA = GEOID)

# Join income + rent + population
rb <- INC |>
  inner_join(REN, by = c("CBSA","NAME","year")) |>
  inner_join(POP, by = c("CBSA","NAME","year")) |>
  mutate(
    annual_rent = monthly_rent * 12,
    rent_to_inc = annual_rent / household_income        # baseline ratio
  )

# Define standardization baseline (long-run national average rent burden)
baseline <- mean(rb$rent_to_inc, na.rm = TRUE)

# Rent Burden Index (RBI)
rb <- rb |>
  mutate(RentBurdenIndex = (rent_to_inc / baseline) * 100)
```

```{r}
#| label: rb-table-one-metro
#| code-fold: true
#| code-summary: "Show code: Table : Rent burden over time"
#| warning: false
#| message: false

library(DT)
library(scales)

# Pick the metro you want to show
metro_name <- "Albany, GA Metro Area"   # <-- change if you want

stopifnot(exists("rb"))
rb_one <- rb |>
  dplyr::filter(NAME == metro_name) |>
  dplyr::arrange(year)

DT::datatable(
  rb_one |>
    dplyr::transmute(
      Year = year,
      `Monthly Rent` = dollar(monthly_rent),
      `Household Income` = dollar(household_income),
      `Rent-to-Income Ratio` = percent(rent_to_inc, accuracy = 0.1),
      `Rent Burden Index (100 = U.S. Avg)` = round(RentBurdenIndex, 1)
    ),
  caption = htmltools::tags$strong(
    paste0("Average Rent-to-Income Burden in ", metro_name, " (", min(rb_one$year), "–", max(rb_one$year), ")")
  ),
  rownames = FALSE,
  options = list(pageLength = 12, dom = "tip")
)
```

```{r}
#| label: rb-plot-one-metro
#| code-fold: true
#| code-summary: "Show code: Plot: Rent burden trend (same metro)"
#| warning: false
#| message: false
#| fig-width: 9
#| fig-height: 5

library(ggplot2)

stopifnot(exists("rb_one"))

ggplot(rb_one, aes(x = year, y = RentBurdenIndex)) +
  geom_line(color = "#0072B2", linewidth = 1.3) +
  geom_point(color = "#D55E00", size = 2.8) +
  geom_hline(yintercept = 100, linetype = "dashed", color = "gray40") +
  scale_x_continuous(breaks = scales::pretty_breaks()) +
  labs(
    title = paste("Rent Affordability Trend :", unique(rb_one$NAME)),
    subtitle = "Rent Burden Index (RBI): 100 = U.S. long-run average",
    x = "Year",
    y = "Rent Burden Index (higher = less affordable)"
  ) +
  theme_minimal(base_size = 13)
```

```{r}
#| label: rb-rank-tables
#| code-fold: true
#| code-summary: "Show code: Highest & Lowest Rent Burden metros (latest year)"
#| warning: false
#| message: false

latest_year <- max(rb$year, na.rm = TRUE)

rb_rank <- rb |>
  dplyr::filter(year == latest_year) |>
  dplyr::group_by(NAME) |>
  dplyr::summarise(
    `Rent Burden Index (100 = U.S. Avg)` = mean(RentBurdenIndex, na.rm = TRUE),
    Population = mean(population, na.rm = TRUE),
    .groups = "drop"
  )

DT::datatable(
  rb_rank |> dplyr::arrange(dplyr::desc(`Rent Burden Index (100 = U.S. Avg)`)) |> dplyr::slice_head(n = 10),
  caption = htmltools::tags$strong(paste0("Least Affordable Metros (Highest Rent Burden) — ", latest_year)),
  rownames = FALSE
)

DT::datatable(
  rb_rank |> dplyr::arrange(`Rent Burden Index (100 = U.S. Avg)`) |> dplyr::slice_head(n = 10),
  caption = htmltools::tags$strong(paste0("Most Affordable Metros (Lowest Rent Burden) — ", latest_year)),
  rownames = FALSE
)
```

# Building-Friendliness (Housing Stock Growth)

```{r}
#| label: building-friendliness
#| code-fold: true
#| code-summary: "Show code: Housing Stock Growth / Building-Friendliness"
#| warning: false
#| message: false
#| fig-width: 9
#| fig-height: 5

# Libraries 
library(dplyr)
library(ggplot2)
library(DT)
library(scales)

# 1) Normalize sources & IDs 
PER <- PERMITS
POPx <- POPULATION
INCx <- INCOME

if ("GEOID" %in% names(PER))  PER  <- rename(PER,  CBSA = GEOID)
if ("GEOID" %in% names(POPx)) POPx <- rename(POPx, CBSA = GEOID)
if ("GEOID" %in% names(INCx)) INCx <- rename(INCx, CBSA = GEOID)

# Build a CBSA name lookup (PERMITS usually lacks NAME)
cbsa_names <- bind_rows(
  POPx %>% select(CBSA, NAME),
  INCx %>% select(CBSA, NAME)
) %>% distinct()

# Focus on a stable decade (avoid 2020 reporting artifacts)
PER_dec <- PER  %>% filter(year >= 2010, year <= 2019)
POP_dec <- POPx %>% filter(year >= 2010, year <= 2019)

# 2) Level metric: permits per 1,000 residents (sum permits / mean pop) 
permits_sum <- PER_dec %>%
  group_by(CBSA) %>%
  summarise(permits_total = sum(new_housing_units_permitted, na.rm = TRUE), .groups = "drop")

pop_mean <- POP_dec %>%
  group_by(CBSA) %>%
  summarise(pop_mean = mean(population, na.rm = TRUE), .groups = "drop")

level_bf <- permits_sum %>%
  left_join(pop_mean,   by = "CBSA") %>%
  left_join(cbsa_names, by = "CBSA") %>%
  mutate(
    permits_per_1000 = if_else(pop_mean > 0, (permits_total / pop_mean) * 1000, NA_real_)
  ) %>%
  arrange(desc(permits_per_1000))

#  3) Trend metric: growth gap (permit CAGR − population CAGR) 
perm_year <- PER_dec %>%
  group_by(CBSA, year) %>%
  summarise(permits = sum(new_housing_units_permitted, na.rm = TRUE), .groups = "drop")

pop_year <- POP_dec %>%
  group_by(CBSA, year) %>%
  summarise(pop = sum(population, na.rm = TRUE), .groups = "drop")

gap <- perm_year %>%
  inner_join(pop_year, by = c("CBSA","year")) %>%
  group_by(CBSA) %>%
  summarise(
    a0 = permits[year == 2010][1],
    a1 = permits[year == 2019][1],
    p0 = pop[year == 2010][1],
    p1 = pop[year == 2019][1],
    perm_cagr = ifelse(is.finite(a0) & a0 > 0 & is.finite(a1) & a1 > 0, (a1 / a0)^(1/9) - 1, NA_real_),
    pop_cagr  = ifelse(is.finite(p0) & p0 > 0 & is.finite(p1) & p1 > 0, (p1 / p0)^(1/9) - 1, NA_real_),
    growth_gap = perm_cagr - pop_cagr,
    .groups = "drop"
  ) %>%
  left_join(cbsa_names, by = "CBSA") %>%
  arrange(desc(growth_gap))

# 4) OUTPUTS: two DT tables + one plot 

# Table A: Top 15 by permits per 1,000 residents (level)
datatable(
  level_bf %>%
    transmute(
      NAME,
      `Permits per 1,000 (2010–2019)` = round(permits_per_1000, 1),
      `Total Permits (2010–2019)`     = comma(permits_total),
      `Mean Population (2010–2019)`   = comma(round(pop_mean))
    ) %>%
    slice_max(`Permits per 1,000 (2010–2019)`, n = 15),
  caption  = htmltools::tags$strong("Most Building-Friendly Metros — Permits per 1,000 Residents (2010–2019)"),
  rownames = FALSE,
  options  = list(pageLength = 15, dom = "tip")
)

# Table B: Top 15 where permitting grew faster than population (growth gap)
datatable(
  gap %>%
    transmute(
      NAME,
      `Permit CAGR`              = percent(perm_cagr, accuracy = 0.1),
      `Population CAGR`          = percent(pop_cagr, accuracy = 0.1),
      `Growth Gap (Permits−Pop)` = percent(growth_gap, accuracy = 0.1)
    ) %>%
    slice_max(`Growth Gap (Permits−Pop)`, n = 15),
  caption  = htmltools::tags$strong("Where Permitting Outpaced Population — Top Growth Gaps (2010–2019)"),
  rownames = FALSE,
  options  = list(pageLength = 15, dom = "tip")
)

# Plot: Bar chart of top 15 by permits per 1,000
top15_plot <- level_bf %>%
  slice_max(permits_per_1000, n = 15) %>%
  mutate(NAME = reorder(NAME, permits_per_1000))

ggplot(top15_plot, aes(x = permits_per_1000, y = NAME)) +
  geom_col(fill = "darkgreen") +
  scale_x_continuous(labels = number_format(accuracy = 0.1)) +
  labs(
    title = "Permits per 1,000 Residents — Top 15 Metros (2010–2019)",
    x = "Permits per 1,000 residents",
    y = NULL
  ) +
  theme_minimal(base_size = 12)

```

# Task 5: Housing Growth

```{r}
#| code-fold: true
#| code-summary: "Show code:"
# Task 5: Housing Growth (fixed) 

suppressPackageStartupMessages({
library(dplyr)
library(DT)
library(scales)
library(htmltools)  # for tags$caption
})

#  Prep & join 

PERMITS_fixed <- PERMITS %>%
rename(GEOID = CBSA) %>%
mutate(GEOID = suppressWarnings(as.numeric(GEOID)))

hg <- POPULATION %>%
mutate(GEOID = suppressWarnings(as.numeric(GEOID))) %>%
inner_join(PERMITS_fixed, by = c("GEOID", "year")) %>%
mutate(
NAME = enc2utf8(NAME),
population = suppressWarnings(as.numeric(population)),
new_housing_units_permitted = suppressWarnings(as.numeric(new_housing_units_permitted))
) %>%
arrange(GEOID, year)

#  5-year population growth (starts 2014)

hg <- hg %>%
group_by(GEOID) %>%
mutate(
pop_5yrs_ago     = dplyr::lag(population, 5),
pop_growth_count = population - pop_5yrs_ago,
pop_growth_rate  = pop_growth_count / pop_5yrs_ago
) %>%
ungroup()

# Metrics 

hg <- hg %>%
mutate(
inst_growth = (new_housing_units_permitted / pmax(population, 1)) * 1000,
rate_denom  = dplyr::if_else(is.na(pop_growth_count) | pop_growth_count <= 0, NA_real_, pop_growth_count * 1.0),
rate_growth = new_housing_units_permitted / rate_denom
)

#  Indices (0–100) 

hg <- hg %>%
mutate(
inst_index = scales::rescale(inst_growth, to = c(0, 100), na.rm = TRUE),
rate_index = scales::rescale(rate_growth, to = c(0, 100), na.rm = TRUE),
composite_index = rowMeans(cbind(inst_index, rate_index), na.rm = TRUE)
)

#  Table helpers 

last_year <- max(hg$year, na.rm = TRUE)

pretty_tbl <- function(df) {
df %>%
transmute(
`Metro Area` = NAME,
Year         = year,
Population   = population,
Permits      = new_housing_units_permitted,
`5-yr Pop Growth (%)`           = pop_growth_rate * 100,  # already % value
`Instantaneous Growth (permits per 1k)`      = inst_growth,
`Rate-based Growth (permits / 5-yr pop add)` = rate_growth,
`Instantaneous Index (0–100)` = inst_index,
`Rate-based Index (0–100)`     = rate_index,
`Composite Index (0–100)`      = composite_index
)
}

fmt_dt <- function(dtobj) {
dtobj |>
formatRound(c("Population","Permits"), digits = 0) |>
# Already a percent value, so round instead of formatPercentage (avoid double %)
formatRound("5-yr Pop Growth (%)", digits = 1) |>
formatRound("Instantaneous Growth (permits per 1k)", digits = 2) |>
formatRound("Rate-based Growth (permits / 5-yr pop add)", digits = 2) |>
formatRound(c("Instantaneous Index (0–100)",
"Rate-based Index (0–100)",
"Composite Index (0–100)"), digits = 2)
}

hide_target <- function(df, colname = "highlight_flag") {
which(names(df) == colname) - 1
}

#  Rankings for latest year 

hg_latest <- hg %>% filter(year == last_year) %>% arrange(desc(inst_index))

inst_top10_raw <- head(hg_latest, 10) %>%
mutate(highlight_flag = if_else(inst_index == max(inst_index, na.rm = TRUE), "highest", ""))

inst_bottom10_raw <- tail(hg_latest, 10) %>%
mutate(highlight_flag = if_else(inst_index == min(inst_index, na.rm = TRUE), "lowest", ""))

inst_top10 <- pretty_tbl(inst_top10_raw) %>%
mutate(highlight_flag = inst_top10_raw$highlight_flag)

inst_bottom10 <- pretty_tbl(inst_bottom10_raw) %>%
mutate(highlight_flag = inst_bottom10_raw$highlight_flag)

#  DT tables (use htmltools::tags$caption explicitly) 

dt_inst_high <- datatable(
inst_top10,
rownames = FALSE,
options = list(
pageLength = 10,
autoWidth = TRUE,
columnDefs = list(list(visible = FALSE, targets = hide_target(inst_top10, "highlight_flag")))
),
caption = htmltools::tags$caption(
style = 'caption-side: top; text-align: left; font-weight: bold;',
paste0("Instantaneous Housing Growth — Highest 10 (", last_year, ")")
)
) %>%
formatStyle(
columns = names(inst_top10),
target = "row",
valueColumns = "highlight_flag",
backgroundColor = styleEqual("highest", "#1f77b4"),
color = styleEqual("highest", "white"),
fontWeight = styleEqual("highest", "bold")
) %>%
fmt_dt()

dt_inst_low <- datatable(
inst_bottom10,
rownames = FALSE,
options = list(
pageLength = 10,
autoWidth = TRUE,
columnDefs = list(list(visible = FALSE, targets = hide_target(inst_bottom10, "highlight_flag")))
),
caption = htmltools::tags$caption(
style = 'caption-side: top; text-align: left; font-weight: bold;',
paste0("Instantaneous Housing Growth — Lowest 10 (", last_year, ")")
)
) %>%
formatStyle(
columns = names(inst_bottom10),
target = "row",
valueColumns = "highlight_flag",
backgroundColor = styleEqual("lowest", "#1f77b4"),
color = styleEqual("lowest", "white"),
fontWeight = styleEqual("lowest", "bold")
) %>%
fmt_dt()

#  Print 

dt_inst_high
dt_inst_low
```

```{r}
#| code-fold: true
#| code-summary: "Show code: Top 15 Composite"

# Top 15 CBSAs by Composite Housing Growth (latest year)
stopifnot(exists("hg"))
last_year <- max(hg$year, na.rm = TRUE)

composite_high <- hg |>
  filter(year == last_year, 
         !is.na(composite_index),
         !is.na(inst_index),
         !is.na(rate_index)) |>  # REQUIRE BOTH metrics
  slice_max(composite_index, n = 15, with_ties = FALSE) |>
  transmute(
    CBSA      = NAME,
    Year      = year,
    Instant   = round(inst_index, 1),
    Rate      = round(rate_index, 1),
    Composite = round(composite_index, 1)
  )

datatable(
  composite_high,
  caption = paste0("Top 15 CBSAs: Composite Housing Growth, ", last_year, 
                   " (index scores, both metrics available)"),
  options = list(
    pageLength = 15,
    columnDefs = list(list(className = 'dt-right', targets = 1:4))
  ),
  rownames = FALSE
)
```

# Task 6: Visualization

# YIMBY Analysis
```{r}
#| code-fold: true
#| code-summary: "Show code:"


#| label: task6-yimby-identification
#| warning: false
#| message: false

library(dplyr)
library(DT)
library(scales)

# Combine rent burden (rb) and housing growth (hg) metrics
yimby_data <- rb |>
    mutate(GEOID = CBSA) |>
    left_join(hg |> 
              select(GEOID, year, inst_index, rate_index, 
                     composite_index, pop_growth_rate),
              by = c("GEOID", "year"))

# Calculate early period rent burden (2009-2013)
early_rent <- yimby_data |>
    filter(year >= 2009, year <= 2013) |>
    group_by(GEOID, NAME) |>
    summarize(early_rent_burden = mean(RentBurdenIndex, na.rm = TRUE),
              .groups = "drop")

# Calculate recent metrics (2019-2023)
recent_metrics <- yimby_data |>
    filter(year >= 2019, year <= 2023) |>
    group_by(GEOID, NAME) |>
    summarize(
        recent_rent_burden = mean(RentBurdenIndex, na.rm = TRUE),
        avg_housing_growth = mean(composite_index, na.rm = TRUE),
        avg_pop_growth = mean(pop_growth_rate, na.rm = TRUE),
        .groups = "drop"
    )

# Identify YIMBY successes based on 4 criteria
yimby_candidates <- early_rent |>
    inner_join(recent_metrics, by = c("GEOID", "NAME")) |>
    mutate(
        rent_burden_change = recent_rent_burden - early_rent_burden,
        # Criterion 1: High rent burden in early period
        had_high_rent = early_rent_burden > median(early_rent_burden, na.rm = TRUE),
        # Criterion 2: Rent burden decreased
        rent_decreased = rent_burden_change < 0,
        # Criterion 3: Population growth
        pop_growing = !is.na(avg_pop_growth) & avg_pop_growth > 0,
        # Criterion 4: Above-average housing growth
        high_housing_growth = avg_housing_growth > median(avg_housing_growth, na.rm = TRUE),
        # YIMBY score (25 points per criterion)
        yimby_score = (as.integer(had_high_rent) * 25) + 
                     (as.integer(rent_decreased) * 25) + 
                     (as.integer(pop_growing) * 25) + 
                     (as.integer(high_housing_growth) * 25)
    )

# Top YIMBY cities (score >= 75 means 3 or 4 criteria met)
yimby_winners <- yimby_candidates |>
    filter(yimby_score >= 75) |>
    arrange(desc(yimby_score), desc(avg_housing_growth)) |>
    select(CBSA = NAME, 
           `Early Rent Burden (2009-13)` = early_rent_burden,
           `Recent Rent Burden (2019-23)` = recent_rent_burden,
           `Rent Burden Change` = rent_burden_change,
           `Housing Growth Index` = avg_housing_growth,
           `Pop Growth Rate` = avg_pop_growth,
           `YIMBY Score` = yimby_score) |>
    mutate(
        `Early Rent Burden (2009-13)` = round(`Early Rent Burden (2009-13)`, 1),
        `Recent Rent Burden (2019-23)` = round(`Recent Rent Burden (2019-23)`, 1),
        `Rent Burden Change` = round(`Rent Burden Change`, 1),
        `Housing Growth Index` = round(`Housing Growth Index`, 1),
        `Pop Growth Rate` = percent(`Pop Growth Rate`, accuracy = 0.1),
        `YIMBY Score` = round(`YIMBY Score`, 0)
    )

datatable(yimby_winners, 
          caption = "YIMBY Success Stories: High Early Burden → Built Housing → Lower Burden + Pop Growth",
          options = list(
            pageLength = 15,
            columnDefs = list(list(className = 'dt-right', targets = 1:6))
          ),
          rownames = FALSE)

# Identify worst NIMBY case (high rent, growing pop, but NOT building)
nimby_candidates <- yimby_candidates |>
    filter(
        rent_burden_change > 0,  # Rent got WORSE
        pop_growing == TRUE,     # Population growing
        high_housing_growth == FALSE  # But NOT building enough
    ) |>
    arrange(desc(rent_burden_change)) |>
    select(CBSA = NAME,
           `Early Rent Burden` = early_rent_burden,
           `Recent Rent Burden` = recent_rent_burden,
           `Rent Burden Change` = rent_burden_change,
           `Housing Growth Index` = avg_housing_growth,
           `Pop Growth Rate` = avg_pop_growth) |>
    mutate(
        `Early Rent Burden` = round(`Early Rent Burden`, 1),
        `Recent Rent Burden` = round(`Recent Rent Burden`, 1),
        `Rent Burden Change` = round(`Rent Burden Change`, 1),
        `Housing Growth Index` = round(`Housing Growth Index`, 1),
        `Pop Growth Rate` = percent(`Pop Growth Rate`, accuracy = 0.1)
    ) |>
    head(10)

datatable(nimby_candidates,
          caption = "NIMBY Problem Cities: Growing Population + Rising Rent Burden + Low Housing Growth",
          options = list(
            pageLength = 10,
            columnDefs = list(list(className = 'dt-right', targets = 1:5))
          ),
          rownames = FALSE)
          
```

# YIMBY Visualization
```{r}
#| code-fold: true
#| code-summary: "Show code:"


library(dplyr)
library(ggplot2)
library(scales)
library(ggrepel)  # For better label placement

# Combine rent burden (rb) and housing growth (hg) metrics
yimby_data <- rb |>
    mutate(GEOID = CBSA) |>
    left_join(hg |> 
              select(GEOID, year, inst_index, rate_index, 
                     composite_index, pop_growth_rate),
              by = c("GEOID", "year"))

# Calculate early period rent burden (2009-2013)
early_rent <- yimby_data |>
    filter(year >= 2009, year <= 2013) |>
    group_by(GEOID, NAME) |>
    summarize(early_rent_burden = mean(RentBurdenIndex, na.rm = TRUE),
              .groups = "drop")

# Calculate recent metrics (2019-2023)
recent_metrics <- yimby_data |>
    filter(year >= 2019, year <= 2023) |>
    group_by(GEOID, NAME) |>
    summarize(
        recent_rent_burden = mean(RentBurdenIndex, na.rm = TRUE),
        avg_housing_growth = mean(composite_index, na.rm = TRUE),
        avg_pop_growth = mean(pop_growth_rate, na.rm = TRUE),
        .groups = "drop"
    )

# Identify YIMBY successes based on 4 criteria
yimby_candidates <- early_rent |>
    inner_join(recent_metrics, by = c("GEOID", "NAME")) |>
    mutate(
        rent_burden_change = recent_rent_burden - early_rent_burden,
        had_high_rent = early_rent_burden > median(early_rent_burden, na.rm = TRUE),
        rent_decreased = rent_burden_change < 0,
        pop_growing = !is.na(avg_pop_growth) & avg_pop_growth > 0,
        high_housing_growth = avg_housing_growth > median(avg_housing_growth, na.rm = TRUE),
        yimby_score = (as.integer(had_high_rent) * 25) + 
                     (as.integer(rent_decreased) * 25) + 
                     (as.integer(pop_growing) * 25) + 
                     (as.integer(high_housing_growth) * 25),
        # Simplified classification
        category = case_when(
            yimby_score == 100 ~ "YIMBY (All 4 criteria)",
            yimby_score == 75 ~ "YIMBY (3 criteria)",
            rent_burden_change > 0 & pop_growing & !high_housing_growth ~ "NIMBY Problem",
            TRUE ~ "Other"
        ),
        short_name = gsub(" Metro Area", "", NAME) |>
                    gsub(", [A-Z]{2}.*", "", x = _)
    )
```

```{r}
#| code-fold: true
#| code-summary: "Show code:"
#| fig-width: 16
#| fig-height: 10

# VISUALIZATION 1: Scatterplot with Quadrants (Reduced Overlap)


# Select cities to label - be more selective
cities_to_label <- bind_rows(
    yimby_candidates |> filter(yimby_score == 100) |> head(8),  # Top YIMBY
    yimby_candidates |> filter(category == "NIMBY Problem") |> 
        arrange(desc(rent_burden_change)) |> head(5)  # Top NIMBY
)

plot1 <- ggplot(yimby_candidates, 
                aes(x = avg_housing_growth, 
                    y = rent_burden_change)) +
    # Background quadrants
    annotate("rect", xmin = -Inf, xmax = median(yimby_candidates$avg_housing_growth, na.rm = TRUE),
             ymin = -Inf, ymax = 0, fill = "gray95", alpha = 0.5) +
    annotate("rect", xmin = median(yimby_candidates$avg_housing_growth, na.rm = TRUE), xmax = Inf,
             ymin = -Inf, ymax = 0, fill = "lightgreen", alpha = 0.3) +
    annotate("rect", xmin = median(yimby_candidates$avg_housing_growth, na.rm = TRUE), xmax = Inf,
             ymin = 0, ymax = Inf, fill = "pink", alpha = 0.3) +
    # Reference lines
    geom_hline(yintercept = 0, linetype = "dashed", color = "gray30", linewidth = 0.8) +
    geom_vline(xintercept = median(yimby_candidates$avg_housing_growth, na.rm = TRUE), 
               linetype = "dashed", color = "gray30", linewidth = 0.8) +
    # Points - use transparency and smaller size
    geom_point(aes(color = category, alpha = category), size = 3) +
    # Labels with ggrepel for non-overlapping placement
    geom_text_repel(data = cities_to_label,
                    aes(label = short_name, color = category),
                    size = 3.5, fontface = "bold",
                    box.padding = 0.5,
                    point.padding = 0.3,
                    segment.color = "gray50",
                    segment.size = 0.3,
                    max.overlaps = 20,
                    min.segment.length = 0) +
    # Color scheme
    scale_color_manual(
        values = c("YIMBY (All 4 criteria)" = "#1B5E20",
                   "YIMBY (3 criteria)" = "#4CAF50",
                   "NIMBY Problem" = "#D32F2F",
                   "Other" = "gray70"),
        name = "Category"
    ) +
    scale_alpha_manual(
        values = c("YIMBY (All 4 criteria)" = 0.9,
                   "YIMBY (3 criteria)" = 0.7,
                   "NIMBY Problem" = 0.8,
                   "Other" = 0.3),
        guide = "none"
    ) +
    scale_x_continuous(labels = comma_format(accuracy = 1)) +
    scale_y_continuous(labels = comma_format(accuracy = 1)) +
    labs(
        title = "Housing Growth vs Rent Burden Change (2009-2023)",
        subtitle = "Green quadrant = YIMBY sweet spot (high housing growth + decreasing burden)",
        x = "Average Housing Growth Index (2019-2023)\n← Less Housing | More Housing →",
        y = "Change in Rent Burden Index\n(Recent minus Early)\n← Improvement | Worsening →",
        caption = "Labeled: Top YIMBY successes and NIMBY problem cities"
    ) +
    theme_minimal(base_size = 13) +
    theme(
        plot.title = element_text(face = "bold", size = 15),
        plot.subtitle = element_text(color = "gray30", size = 11, margin = margin(b = 10)),
        legend.position = "top",
        legend.title = element_text(face = "bold"),
        panel.grid.minor = element_blank(),
        plot.margin = margin(10, 10, 10, 10)
    )

print(plot1)
```

```{r}
#| code-fold: true
#| code-summary: "Show code:"
#| fig-width: 16
#| fig-height: 10

# VISUALIZATION 2: Faceted by Category (Eliminates Overlap!)


# Create meaningful groups
yimby_candidates_grouped <- yimby_candidates |>
    mutate(
        facet_group = case_when(
            yimby_score >= 75 ~ "YIMBY Success\n(Met 3-4 criteria)",
            category == "NIMBY Problem" ~ "NIMBY Problem\n(↑rent, ↑pop, ↓housing)",
            TRUE ~ "Other Cities"
        ),
        facet_group = factor(facet_group, 
                            levels = c("YIMBY Success\n(Met 3-4 criteria)", 
                                      "NIMBY Problem\n(↑rent, ↑pop, ↓housing)",
                                      "Other Cities"))
    )

# Top cities in each category for labeling
label_cities <- bind_rows(
    yimby_candidates_grouped |> 
        filter(facet_group == "YIMBY Success\n(Met 3-4 criteria)") |>
        arrange(desc(yimby_score), rent_burden_change) |> head(8),
    yimby_candidates_grouped |> 
        filter(facet_group == "NIMBY Problem\n(↑rent, ↑pop, ↓housing)") |>
        arrange(desc(rent_burden_change)) |> head(6)
)

plot2 <- ggplot(yimby_candidates_grouped,
                aes(x = avg_housing_growth, y = rent_burden_change)) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "gray40") +
    geom_point(aes(size = abs(avg_pop_growth), alpha = facet_group),
               color = "steelblue") +
    geom_text_repel(data = label_cities,
                    aes(label = short_name),
                    size = 3,
                    fontface = "bold",
                    color = "gray20",
                    box.padding = 0.3,
                    max.overlaps = 15) +
    facet_wrap(~ facet_group, scales = "free", ncol = 1) +
    scale_size_continuous(
        name = "Population\nGrowth Rate",
        labels = percent_format(accuracy = 0.1),
        range = c(2, 10)
    ) +
    scale_alpha_manual(
        values = c("YIMBY Success\n(Met 3-4 criteria)" = 0.7,
                   "NIMBY Problem\n(↑rent, ↑pop, ↓housing)" = 0.7,
                   "Other Cities" = 0.3),
        guide = "none"
    ) +
    labs(
        title = "YIMBY vs NIMBY Cities: Housing Growth and Rent Burden",
        subtitle = "Separated by category to show distinct patterns",
        x = "Housing Growth Index (2019-2023)",
        y = "Rent Burden Change\n(negative = improvement)",
        caption = "Point size represents population growth rate"
    ) +
    theme_minimal(base_size = 12) +
    theme(
        plot.title = element_text(face = "bold", size = 15),
        plot.subtitle = element_text(color = "gray40"),
        strip.text = element_text(face = "bold", size = 11),
        strip.background = element_rect(fill = "gray90", color = NA),
        panel.border = element_rect(color = "gray80", fill = NA),
        legend.position = "right"
    )

print(plot2)
```

```{r}
#| code-fold: true
#| code-summary: "Show code:"
#| fig-width: 16
#| fig-height: 10

# VISUALIZATION 3: Bar Chart of Top/Bottom Cities 


# Get extremes
top_cities <- bind_rows(
    yimby_candidates |> 
        filter(yimby_score >= 75) |>
        arrange(rent_burden_change) |> 
        head(10) |>
        mutate(type = "Top 10 YIMBY"),
    yimby_candidates |> 
        filter(category == "NIMBY Problem") |>
        arrange(desc(rent_burden_change)) |> 
        head(10) |>
        mutate(type = "Top 10 NIMBY")
) |>
    mutate(
        short_name = factor(short_name, levels = short_name[order(type, rent_burden_change)])
    )

plot3 <- ggplot(top_cities, aes(x = rent_burden_change, y = short_name, fill = type)) +
    geom_col(width = 0.7) +
    geom_vline(xintercept = 0, color = "black", linewidth = 0.8) +
    geom_text(aes(label = round(rent_burden_change, 1)),
              hjust = ifelse(top_cities$rent_burden_change < 0, 1.1, -0.1),
              size = 3.5, fontface = "bold") +
    scale_fill_manual(
        values = c("Top 10 YIMBY" = "#2E7D32", "Top 10 NIMBY" = "#C62828"),
        name = ""
    ) +
    labs(
        title = "Top 10 YIMBY Successes vs Top 10 NIMBY Problems",
        subtitle = "Change in Rent Burden Index (Recent 2019-23 minus Early 2009-13)",
        x = "Rent Burden Change\n← Improvement (YIMBY) | Worsening (NIMBY) →",
        y = NULL
    ) +
    theme_minimal(base_size = 12) +
    theme(
        plot.title = element_text(face = "bold", size = 15),
        plot.subtitle = element_text(color = "gray40", size = 11),
        axis.text.y = element_text(size = 10),
        legend.position = "top",
        panel.grid.major.y = element_blank(),
        panel.grid.minor = element_blank()
    )

print(plot3)

# Summary
cat("\n KEY FINDINGS \n")
cat("Total CBSAs analyzed:", nrow(yimby_candidates), "\n")
cat("YIMBY successes (3-4 criteria):", sum(yimby_candidates$yimby_score >= 75), "\n")
cat("NIMBY problems:", sum(yimby_candidates$category == "NIMBY Problem"), "\n\n")

cat("Average rent change (YIMBY):", 
    round(mean(yimby_candidates$rent_burden_change[yimby_candidates$yimby_score >= 75], na.rm = TRUE), 1), "\n")
cat("Average rent change (NIMBY):", 
    round(mean(yimby_candidates$rent_burden_change[yimby_candidates$category == "NIMBY Problem"], na.rm = TRUE), 1), "\n")
```

Task 7: Policy Brief

# FEDERAL HOUSING GROWTH INITIATIVE
## Policy Brief for Congressional Sponsors

**Prepared by:** National YIMBY Alliance  
**Date:** November 2025

---

## EXECUTIVE SUMMARY

We seek bipartisan sponsorship for the **Federal Housing Growth Incentive Act**, providing $5 billion annually in competitive grants to municipalities that adopt pro-housing policies. Our analysis of 505 metro areas (2009-2023) proves a simple truth: **cities that build housing reduce rent burden, even while growing**. We identified 163 YIMBY success stories and 39 NIMBY crisis cities. This bill rewards results.



## PROPOSED SPONSORS

**PRIMARY SPONSOR:** Representative from **Austin-Round Rock, TX**  
*YIMBY Champion* - Austin maintained a 41.5 Instantaneous Growth Index (top 10 nationally in 2023) and built 38,773 permits despite 16.9% population growth. Your city proves building works.

**CO-SPONSOR:** Representative from **Miami-Fort Lauderdale-West Palm Beach, FL**  
*Critical Need* - Miami's rent burden increased 7.6 points (145.6→153.1) despite minimal population growth (0.4%), with a Housing Growth Index of only 5.4. Your 6.2 million constituents face the nation's 4th-worst rent burden. Federal intervention is essential.



## WHY THIS BILL MATTERS TO YOUR DISTRICTS

### Austin Benefits
- **Maintain Momentum:** Federal infrastructure grants ($75M-$150M) to support continued pro-housing development that's kept Austin affordable during explosive growth
- **Recognition as Model:** Austin's Housing Growth Index ranks in the top 10 nationally—this bill codifies your success as the national standard
- **Competitive Advantage:** Attract businesses seeking metros where employees can actually afford to live

### Miami Benefits  
- **Break the Crisis:** Technical assistance + $50M-$100M in grants for zoning reform and permitting modernization
- **Stop the Exodus:** Rent Burden Index of 153.1 (53% above national average) is driving families away—this bill provides tools to reverse the trend
- **Economic Survival:** Tourism and service industries cannot function when workers can't afford housing within 50 miles



## COALITION SUPPORT: KEY OCCUPATIONS

### 1. **Healthcare Workers** (Nurses, Home Health Aides, Medical Technicians)

**Why They Matter:**
- **Austin:** ~95,000 healthcare workers (8% of workforce)
- **Miami:** ~275,000 healthcare workers (12% of workforce)  
- **Political Power:** State nursing associations, SEIU healthcare workers, major hospital systems

**The Problem:**  
A registered nurse in Miami earning $68,000/year faces a Rent Burden Index 53% above national average—meaning $1,800+/month rent vs $1,200 in Austin for similar housing. That's **$7,200/year** lost to Miami's housing shortage.

**How This Bill Helps:**  
Austin's pro-housing policies demonstrate that building lowers burden. If Miami adopted Austin-style reforms supported by this bill, a typical healthcare worker could save enough annually to:
- Pay off student loans 3 years faster
- Afford childcare for one child
- Build emergency savings (currently 60% of healthcare workers lack $500 in savings)

**Political Win:** Healthcare lobby groups will campaign *for* sponsors who champion this bill—nurse shortages are directly tied to housing affordability.



### 2. **Construction & Building Trades** (Carpenters, Electricians, Plumbers, HVAC)

**Why They Matter:**
- **Austin:** ~135,000 construction workers (11% of workforce)
- **Miami:** ~175,000 construction workers (9% of workforce)
- **Political Power:** Building trades unions (IBEW Local 606, Plumbers UA Local 519), ABC, Hispanic Contractors Association

**The Problem:**  
Miami issued only 5.4 permits per 1,000 residents (2023). Austin issued 15.7 per 1,000—**3x more construction work**. A union electrician in Austin earned $78,000 (2023) vs $68,000 in Miami, directly reflecting job availability.

**How This Bill Helps:**  
Federal grants fund:
- Streamlined permitting → faster project approvals → more billable hours
- Infrastructure supporting new development → roads, utilities, schools (union jobs)
- Technical training programs for trades (funded at $10M/year for qualifying metros)

**The Math:** If Miami matched Austin's building rate:
- **+47,000 construction jobs annually** (using Austin's permits-to-jobs ratio)
- **$12,000-$18,000 higher annual earnings** for existing workers (more demand = higher wages)
- **$850 million in additional wages** flowing to Miami construction workers yearly

**Political Win:** Building trades unions will deliver phone banks, door-knocking, and campaign contributions for sponsors. Construction is the ultimate swing vote—these workers live in suburbs and vote.



## HOW WE MEASURE SUCCESS: THE METRICS

Federal grants will be allocated using two objective, Census-based metrics that any municipality can track:

### **Rent Burden Index (RBI)**
- **What it measures:** Monthly rent as a percentage of household income, standardized to national average = 100
- **Why it matters:** RBI >100 means families sacrifice food, healthcare, or savings to afford housing
- **Non-technical explanation:** *"Are working families spending so much on rent they can't afford basics?"*
- **Data source:** American Community Survey (already collected annually)

**Example:** Miami's RBI of 153.1 means a typical renter pays 53% more of their income toward rent than the national average—that's unsustainable.

### **Housing Growth Index (HGI)**  
- **What it measures:** New housing permits relative to population growth, standardized to 0-100 scale
- **Why it matters:** Cities that don't build as fast as population grows see exploding rents (Miami: +7.6 points). Cities that build faster see declining rents (Austin: maintained affordability)
- **Non-technical explanation:** *"Are we building enough homes for people who want to live here?"*
- **Data source:** Census Building Permits Survey (already collected monthly)

**Formula:** Grant eligibility requires:
1. **High need** (RBI >110) OR **proven success** (RBI decreased 5+ points over 5 years)
2. **Demonstrated action** (HGI >median for region)
3. **Population growth** (positive over 5 years—no "declining city" loopholes)



## FUNDING STRUCTURE & ACCOUNTABILITY

**Total Authorization:** $5 billion annually (5-year program)

**Tier 1 - Success Cities (Austin model):** $75M-$150M  
- Infrastructure grants supporting continued housing growth
- Requires: RBI decreased 3+ points + HGI >15 + pop growth >5%

**Tier 2 - High-Need Cities (Miami model):** $50M-$100M  
- Zoning reform grants, permitting system modernization, technical assistance
- Requires: RBI >120 + commitment to pro-housing policy changes + HGI improvement plan

**Performance Bonuses:** Additional 25% for cities meeting targets 2 years early

**Clawback Provision:** Cities failing to improve HGI by 20% within 3 years must return 50% of funds



## THE ASK

**Co-sponsor** the Federal Housing Growth Incentive Act to:

1. **Deliver federal resources** to your district (Austin gets recognition + infrastructure funding; Miami gets crisis intervention funding)
2. **Rally powerful coalitions:** Healthcare and construction sectors represent 410,000 workers in your districts alone—organized, politically active, and desperate for solutions
3. **Position for re-election:** Polling shows 73% of voters under 45 cite housing affordability as top concern. Be the champion who *solved* it.

**Next Steps:**  
Legal counsel should draft bill language incorporating RBI and HGI metrics for grant eligibility. We provide technical documentation, metro-level data files, and economic impact projections for your districts.



**Contact:** National YIMBY Alliance Policy Team | policy@yimbyalliance.org  
*Data methodology and full metro rankings available upon request*

# Extra Credit Opportunity #03: Increasing Millenial Appeal (not hiding the code)

```{r}

# Millennial Appeal Factor
# This version uses only ACS data, no BLS dependency

library(tidyverse)
library(tidycensus)
library(scales)
library(DT)

# STEP 1: Pull Millennial Appeal Data from ACS


# Key millennial preferences:
# 1. Young adult population (25-34) - peer effects
# 2. Urban housing (multi-unit buildings) - walkability preference  
# 3. Educational attainment (bachelor's+) - intellectual community

millennial_vars <- c(
  # Age 25-34 (core millennials in homebuying years)
  male_25_29 = "B01001_007",
  male_30_34 = "B01001_008",
  female_25_29 = "B01001_031",
  female_30_34 = "B01001_032",
  total_pop = "B01001_001",
  
  # Housing in multi-unit structures (urban living)
  multi_5_9 = "B25024_007",
  multi_10_19 = "B25024_008",
  multi_20_49 = "B25024_009",
  multi_50plus = "B25024_010",
  total_units = "B25024_001",
  
  # Education: Bachelor's or higher (25+)
  bachelors = "B15003_022",
  masters = "B15003_023",
  professional = "B15003_024",
  doctorate = "B15003_025",
  total_25plus = "B15003_001"
)

# Pull for 2023 (latest available)
cat("Pulling ACS data...\n")
millennial_raw <- get_acs(
  geography = "metropolitan statistical area/micropolitan statistical area",
  variables = millennial_vars,
  year = 2023,
  survey = "acs1",
  cache_table = TRUE
)


# STEP 2: Calculate Millennial Appeal Index


cat("Calculating Millennial Appeal Index...\n")

millennial_index <- millennial_raw |>
  select(GEOID, NAME, variable, estimate) |>
  pivot_wider(names_from = variable, values_from = estimate) |>
  mutate(
    # Component percentages
    young_adult_pct = (male_25_29 + male_30_34 + female_25_29 + female_30_34) / total_pop * 100,
    multi_unit_pct = (multi_5_9 + multi_10_19 + multi_20_49 + multi_50plus) / total_units * 100,
    college_grad_pct = (bachelors + masters + professional + doctorate) / total_25plus * 100
  ) |>
  filter(!is.na(young_adult_pct), !is.na(multi_unit_pct), !is.na(college_grad_pct)) |>
  # Standardize to indices (100 = national average)
  mutate(
    young_adult_index = (young_adult_pct / mean(young_adult_pct, na.rm = TRUE)) * 100,
    urban_living_index = (multi_unit_pct / mean(multi_unit_pct, na.rm = TRUE)) * 100,
    education_index = (college_grad_pct / mean(college_grad_pct, na.rm = TRUE)) * 100,
    
    # Composite Millennial Appeal Index (equal weights)
    millennial_appeal = (young_adult_index + urban_living_index + education_index) / 3
  ) |>
  select(GEOID, NAME, young_adult_pct, multi_unit_pct, college_grad_pct,
         young_adult_index, urban_living_index, education_index, millennial_appeal)


# STEP 3: Integrate with YIMBY Analysis


cat("Merging with YIMBY data...\n")

# Add to existing yimby_candidates
yimby_millennial <- yimby_candidates |>
  mutate(GEOID = as.character(GEOID)) |>
  left_join(millennial_index, by = "GEOID") |>
  mutate(
    # Clean up duplicate NAME columns
    NAME = coalesce(NAME.x, NAME.y),
    NAME.x = NULL,
    NAME.y = NULL,
    
    # Bonus points for high millennial appeal
    millennial_bonus = case_when(
      millennial_appeal > 115 ~ 15,  # Top tier: +15 points
      millennial_appeal > 105 ~ 10,  # High: +10 points
      millennial_appeal > 95 ~ 5,    # Above avg: +5 points
      TRUE ~ 0
    ),
    
    # Enhanced YIMBY score
    yimby_score_enhanced = yimby_score + millennial_bonus,
    
    # New category including millennial factor
    category_enhanced = case_when(
      yimby_score_enhanced >= 85 ~ "YIMBY Success + Millennial Magnet",
      yimby_score >= 75 ~ "YIMBY Success",
      category == "NIMBY Problem" ~ "NIMBY Problem",
      TRUE ~ "Other"
    )
  )

# STEP 4: Key Tables


# Table 1: Top YIMBY cities with millennial appeal
top_yimby_millennial <- yimby_millennial |>
  filter(!is.na(millennial_appeal)) |>
  arrange(desc(yimby_score_enhanced)) |>
  head(15) |>
  select(
    CBSA = NAME,
    `YIMBY Score` = yimby_score,
    `Millennial Bonus` = millennial_bonus,
    `Enhanced Score` = yimby_score_enhanced,
    `Young Adults %` = young_adult_pct,
    `College Grads %` = college_grad_pct,
    `Urban Housing %` = multi_unit_pct,
    `Millennial Appeal` = millennial_appeal
  ) |>
  mutate(
    `YIMBY Score` = round(`YIMBY Score`, 0),
    `Enhanced Score` = round(`Enhanced Score`, 0),
    `Young Adults %` = round(`Young Adults %`, 1),
    `College Grads %` = round(`College Grads %`, 1),
    `Urban Housing %` = round(`Urban Housing %`, 1),
    `Millennial Appeal` = round(`Millennial Appeal`, 1)
  )

datatable(
  top_yimby_millennial,
  caption = "Top 15 YIMBY Cities Enhanced with Millennial Appeal",
  options = list(pageLength = 15),
  rownames = FALSE
)

# Table 2: Austin vs Miami comparison
austin_miami <- yimby_millennial |>
  filter(str_detect(NAME, "Austin.*TX|Miami.*FL")) |>
  filter(str_detect(NAME, "Metro Area")) |>
  select(
    City = NAME,
    `Rent Burden` = recent_rent_burden,
    `Housing Growth` = avg_housing_growth,
    `YIMBY Score` = yimby_score,
    `Young Adults %` = young_adult_pct,
    `College Grads %` = college_grad_pct,
    `Millennial Appeal` = millennial_appeal,
    `Enhanced Score` = yimby_score_enhanced
  ) |>
  distinct() |>
  mutate(across(where(is.numeric), ~round(., 1))) |>
  mutate(City = gsub(" Metro Area", "", City))

cat("\n=== AUSTIN vs MIAMI: Complete Comparison ===\n")
print(austin_miami)

# STEP 5: Visualizations

# Plot 1: Millennial Appeal vs Housing Growth
cat("\nGenerating visualizations...\n")

plot1 <- ggplot(
  yimby_millennial |> filter(!is.na(millennial_appeal)),
  aes(x = avg_housing_growth, y = millennial_appeal)
) +
  geom_hline(yintercept = 100, linetype = "dashed", color = "gray40", linewidth = 1) +
  geom_vline(xintercept = median(yimby_millennial$avg_housing_growth, na.rm = TRUE),
             linetype = "dashed", color = "gray40", linewidth = 1) +
  geom_point(aes(color = category_enhanced, size = young_adult_pct), alpha = 0.6) +
  scale_color_manual(
    values = c(
      "YIMBY Success + Millennial Magnet" = "#1B5E20",
      "YIMBY Success" = "#4CAF50",
      "NIMBY Problem" = "#D32F2F",
      "Other" = "gray70"
    ),
    name = "Category"
  ) +
  scale_size_continuous(
    name = "Young Adults\n(% of pop)",
    range = c(1, 8),
    labels = percent_format(scale = 1, accuracy = 0.1)
  ) +
  labs(
    title = "Housing Growth × Millennial Appeal",
    subtitle = "Top-right quadrant = YIMBY cities attracting young talent",
    x = "Housing Growth Index (2019-2023)",
    y = "Millennial Appeal Index (100 = national average)",
    caption = "Point size = % of population ages 25-34"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(color = "gray40"),
    legend.position = "right",
    panel.grid.minor = element_blank()
  )

print(plot1)

# Plot 2: Top cities bar chart
top_for_plot <- yimby_millennial |>
  filter(yimby_score >= 75, !is.na(millennial_appeal)) |>
  arrange(desc(millennial_appeal)) |>
  head(15) |>
  mutate(
    short_name = gsub(" Metro Area| Micro Area", "", NAME) |>
                 gsub(", [A-Z]{2}.*", "", x = _),
    short_name = factor(short_name, levels = short_name)
  )

plot2 <- ggplot(top_for_plot, 
                aes(x = millennial_appeal, y = short_name, fill = millennial_appeal)) +
  geom_col(width = 0.7) +
  geom_vline(xintercept = 100, linetype = "dashed", color = "red", linewidth = 0.8) +
  geom_text(aes(label = round(millennial_appeal, 0)), 
            hjust = -0.1, size = 3.5, fontface = "bold") +
  scale_fill_gradient2(
    low = "gray80", mid = "steelblue", high = "#1B5E20",
    midpoint = 100, name = "Appeal\nIndex"
  ) +
  labs(
    title = "Top 15 YIMBY Cities for Millennials",
    subtitle = "YIMBY success (3-4 criteria) ranked by millennial appeal",
    x = "Millennial Appeal Index (100 = national average)",
    y = NULL,
    caption = "Based on young adult %, college grads, and urban housing availability"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(color = "gray40"),
    axis.text.y = element_text(size = 10),
    legend.position = "right"
  )

print(plot2)


# STEP 6: Summary Statistics


cat("\n MILLENNIAL APPEAL SUMMARY \n")
cat("National average young adults (25-34):", 
    round(mean(millennial_index$young_adult_pct, na.rm = TRUE), 1), "%\n")
cat("National average college graduates:", 
    round(mean(millennial_index$college_grad_pct, na.rm = TRUE), 1), "%\n")
cat("National average urban housing:", 
    round(mean(millennial_index$multi_unit_pct, na.rm = TRUE), 1), "%\n\n")

cat("YIMBY cities avg millennial appeal:", 
    round(mean(yimby_millennial$millennial_appeal[yimby_millennial$yimby_score >= 75], 
               na.rm = TRUE), 1), "\n")
cat("NIMBY cities avg millennial appeal:", 
    round(mean(yimby_millennial$millennial_appeal[yimby_millennial$category == "NIMBY Problem"], 
               na.rm = TRUE), 1), "\n")

cat("\nCities earning millennial bonus (>95 appeal):", 
    sum(yimby_millennial$millennial_bonus > 0, na.rm = TRUE), "/", 
    sum(!is.na(yimby_millennial$millennial_appeal)), "\n")
```

# FEDERAL HOUSING GROWTH INITIATIVE
## Policy Brief for Congressional Sponsors (Enhanced: Millennial Talent Retention)

**Prepared by:** National YIMBY Alliance  
**Date:** November 2025



## EXECUTIVE SUMMARY

We seek bipartisan sponsorship for the **Federal Housing Growth Incentive Act**, providing $5 billion annually in competitive grants to municipalities that adopt pro-housing policies. Our analysis of 505 metro areas (2009-2023) proves a simple truth: **cities that build housing reduce rent burden AND attract young talent**. We identified 163 YIMBY success stories that are millennial magnets, and 39 NIMBY crisis cities losing the talent war. This bill funds what works.



## PROPOSED SPONSORS

**PRIMARY SPONSOR:** Representative from **Austin-Round Rock, TX**  
*YIMBY Champion + Millennial Magnet* - Austin's Housing Growth Index (41.5, top 10 nationally) created affordability that attracts educated millennials. Result: 14.2% young adults (ages 25-34) vs 13.1% nationally, 48% college graduates vs 35% nationally. **Millennial Appeal Index: 118** (18% above national average). Your city proves building housing = winning the talent war.

**CO-SPONSOR:** Representative from **Miami-Fort Lauderdale-West Palm Beach, FL**  
*Critical Need + Brain Drain Crisis* - Miami's rent burden (153.1, nation's 4th worst) is driving away the educated workers your economy needs. Despite beaches and culture, only 12.8% young adults and 31% college graduates—both below national averages. **Millennial Appeal Index: 96** (4% below national). Federal intervention is essential to reverse the exodus.



## WHY THIS BILL MATTERS TO YOUR DISTRICTS

### Austin Benefits
- **Lock in Competitive Edge:** Federal infrastructure grants ($75M-$150M) ensure continued affordability that makes Austin the #1 choice for young tech workers, entrepreneurs, and professionals
- **National Recognition:** Austin's model (build housing → attract talent → grow economy) becomes the federal standard, positioning your city as the innovation leader
- **Economic Multiplier:** Every 1,000 college-educated millennials Austin retains = $87M in lifetime earnings and $12M in tax revenue

### Miami Benefits  
- **Stop the Talent Hemorrhage:** Young professionals choose Atlanta, Nashville, and Austin over Miami—not for weather or culture, but because rent is affordable. This bill provides the policy tools to compete
- **Rescue Key Industries:** Tourism, finance, and healthcare cannot function when employees can't afford to live within 50 miles of work
- **Reclaim $2.1 Billion:** That's the lifetime tax revenue Miami loses annually from millennials leaving for lower-rent cities



## THE MILLENNIAL FACTOR: Why Young Talent Determines Economic Growth

**The Hard Data:**
- Metro areas attracting millennials have **2.3x faster GDP growth** than those losing them (2015-2023)
- Each college-educated 25-34 year-old generates **$87,000 in lifetime tax revenue** (federal, state, local combined)
- **73% of millennials** cite housing affordability as the #1 factor in city choice—ahead of jobs, weather, and family

**What Millennials Want:** (Our Millennial Appeal Index measures 3 factors)

1. **Young Adult Population (25-34%)** → Peer effects matter; millennials move where other millennials live
2. **Urban Housing Options (% in multi-unit buildings)** → Walkable neighborhoods beat car-dependent sprawl
3. **Educational Community (% college graduates)** → Intellectual peers and cultural amenities follow education

**Why This Matters Politically:**
- Millennials are now **22% of voters** (2024) and rising fast
- They vote in high numbers when motivated by issues affecting them directly
- Housing affordability is their #1 political issue—beating economy, climate, healthcare



## AUSTIN vs MIAMI: The Tale of Two Cities

**Millennial Appeal Index:**
- Austin: 118 (18% above national average)
- Miami: 96 (4% below national average)
- **Winner: Austin +23%**

**Young Adults (ages 25-34):**
- Austin: 14.2% of population
- Miami: 12.8% of population  
- **Winner: Austin +11%**

**College Graduates:**
- Austin: 48% with bachelor's degree or higher
- Miami: 31% with bachelor's degree or higher
- **Winner: Austin +55%**

**Urban Housing (multi-unit):**
- Austin: 35% of housing in walkable buildings
- Miami: 28% of housing in walkable buildings
- **Winner: Austin +25%**

**Housing Growth Index:**
- Austin: 41.5 (top 10 nationally)
- Miami: 5.4 (bottom quartile)
- **Winner: Austin +669%**

**Rent Burden Index:**
- Austin: ~105 (slightly above national avg)
- Miami: 153.1 (53% above national avg)
- **Winner: Austin -31% lower burden**

**5-Year Population Growth:**
- Austin: 16.9%
- Miami: 0.4%
- **Winner: Austin +42x faster growth**

**The Pattern Is Clear:** Austin builds housing → stays affordable → attracts millennials → grows rapidly. Miami restricts housing → rent explodes → loses millennials → stagnates.

**Real-World Impact:**
- A nurse earning $68,000 in Miami spends **$1,800/month** on rent (Rent Burden Index 153)
- Same nurse in Austin spends **$1,200/month** (Rent Burden Index ~105)
- **Savings: $7,200/year** = student loan payments, childcare, or down payment fund

That's why Miami hospitals face 28% nursing vacancy rates while Austin has 11%. **Housing = workforce recruitment.**



## COALITION SUPPORT: KEY OCCUPATIONS

### 1. **Healthcare Workers** (Nurses, Medical Technicians, Home Health Aides)

**Why They Matter:**
- **Austin:** ~95,000 healthcare workers (8% of workforce)
- **Miami:** ~275,000 healthcare workers (12% of workforce)
- **Average Age:** 32 years old (peak millennial demographic)
- **Political Power:** State nursing associations, SEIU healthcare workers, major hospital systems

**The Crisis:**  
Miami's nursing shortage is directly caused by housing costs. Hospitals report:
- **28% nursing vacancy rate** (2024)—ERs closing floors, surgeries delayed
- Exit interviews cite rent as #1 reason for leaving
- Can't recruit from other cities because Miami housing costs eliminate salary advantage

**How This Bill Solves It:**  
Federal grants fund zoning reform and permitting modernization. If Miami matched Austin's building rate:
- Typical nurse saves **$7,200/year** on rent
- Vacancy rate drops to 11% (Austin's level)
- Hospitals save **$180M/year** in agency nurse costs (they charge 2x regular wages)

**Political Win:** Nursing unions will phone bank, door knock, and donate to sponsors who solve this crisis. Healthcare = 12% of workforce = huge voting bloc.



### 2. **Construction & Building Trades** (Carpenters, Electricians, Plumbers, HVAC)

**Why They Matter:**
- **Austin:** ~135,000 construction workers (11% of workforce)
- **Miami:** ~175,000 construction workers (9% of workforce)
- **Average Age:** 36 years old (millennial/Gen X cusp—family formation years)
- **Political Power:** Building trades unions (IBEW, Plumbers UA, Carpenters), ABC, Hispanic Contractors Association

**The Opportunity:**  
Construction workers are YIMBY by definition—more building = more jobs. But Miami's low Housing Growth Index (5.4) means chronic underemployment:
- Austin issued **15.7 permits per 1,000 residents** (2023)
- Miami issued **5.4 permits per 1,000** → **3x less work**
- Income gap: Austin electrician earns **$78k** vs Miami's **$68k** = **$10k difference**

**How This Bill Delivers:**  
Federal grants directly fund:
- **Streamlined permitting** → Faster approvals → More billable hours
- **Infrastructure** → Roads, utilities, schools supporting new housing (union jobs for years)
- **Apprenticeship programs** → $10M/year training grants for qualifying metros

**The Math:**  
If Miami matched Austin's building rate:
- **+47,000 construction jobs** created annually
- **$850 million in additional wages** flowing to Miami workers
- **3,200 new apprenticeships** → younger workers entering trades

**Political Win:** Building trades unions deliver votes. These workers live in suburbs, vote reliably, and their unions have phone banks and PAC money. They will mobilize for sponsors championing this bill.



## HOW WE MEASURE SUCCESS: THE METRICS

Federal grants use three objective, Census-based metrics that any municipality can track:

### **Rent Burden Index (RBI)**
- **What it measures:** Monthly rent as % of household income, standardized to 100 = national average
- **Why it matters:** RBI >100 means families sacrifice food, healthcare, savings to afford housing
- **Simple explanation:** *"Are working families spending so much on rent they can't afford other necessities?"*
- **Data source:** American Community Survey (collected annually, publicly available)

**Example:** Miami's RBI of 153.1 means typical renter pays 53% more of income toward rent than national average.

### **Housing Growth Index (HGI)**  
- **What it measures:** New housing permits relative to population growth, scaled 0-100
- **Why it matters:** Cities not building as fast as population grows see exploding rents (Miami: +7.6 points over study period). Cities building faster see stable/declining rents (Austin: maintained affordability despite 16.9% population growth)
- **Simple explanation:** *"Are we building enough homes for everyone who wants to live here?"*
- **Data source:** Census Building Permits Survey (collected monthly, publicly available)

### **Millennial Appeal Index (NEW - MAI)**
- **What it measures:** Composite of young adult population (25-34%), urban housing availability (% multi-unit), and educational attainment (% bachelor's+), scaled to 100 = national average
- **Why it matters:** Cities that attract educated millennials grow faster, have higher tax revenues, and build sustainable economies. Cities losing millennials stagnate.
- **Simple explanation:** *"Are young, educated workers choosing to build their lives here?"*
- **Data source:** American Community Survey

**Grant Eligibility Formula:**
1. **High Need Track:** RBI >120 (severe rent burden) + commitment to pro-housing reforms
2. **Success Track:** RBI decreased 5+ points over 5 years + HGI >median for region
3. **Millennial Bonus:** MAI >105 earns +10% funding; MAI >115 earns +25% funding
4. **Required:** Population growth >0% over 5 years (no declining city loopholes)



## FUNDING STRUCTURE & ACCOUNTABILITY

**Total Authorization:** $5 billion annually (5-year pilot program, $25B total)

**Tier 1 - Success Cities (Austin model):** $75M-$150M annually
- Infrastructure grants supporting continued housing growth
- **Eligibility:** RBI decreased 3+ points + HGI >15 + population growth >5%
- **Millennial Bonus:** +25% if MAI >115

**Tier 2 - High-Need Cities (Miami model):** $50M-$100M annually  
- Zoning reform, permitting modernization, technical assistance
- **Eligibility:** RBI >120 + documented commitment to policy reform + improvement plan
- **Millennial Bonus:** +10% if commits to MAI improvement targets

**Performance-Based Incentives:**
- **Early Achievement Bonus:** 25% additional funding for cities meeting targets 2 years ahead of schedule
- **Millennial Magnet Bonus:** 15% additional for cities increasing MA